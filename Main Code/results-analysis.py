#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
ES Futures Trading Results Analysis

This script provides in-depth analysis of trading results generated by 
the ES futures forecasting and trading signal pipeline.
"""

import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.dates as mdates
import empyrical as ep
import pyfolio as pf
from tabulate import tabulate

def load_results(results_dir='results'):
    """
    Load results from the pipeline output files.
    
    Parameters:
    -----------
    results_dir : str
        Directory containing result files.
        
    Returns:
    --------
    results : dict
        Dictionary containing loaded results.
    """
    results = {}
    
    # Load performance summary
    if os.path.exists(f'{results_dir}/performance_summary.csv'):
        results['performance'] = pd.read_csv(f'{results_dir}/performance_summary.csv', index_col=0)
    
    # Load feature importance
    if os.path.exists(f'{results_dir}/feature_importance.csv'):
        results['importance'] = pd.read_csv(f'{results_dir}/feature_importance.csv', index_col=0)
    
    # Load predictions
    if os.path.exists(f'{results_dir}/model_predictions.csv'):
        results['predictions'] = pd.read_csv(f'{results_dir}/model_predictions.csv', index_col=0)
        results['predictions'].index = pd.to_datetime(results['predictions'].index)
    
    # Load trading signals
    if os.path.exists(f'{results_dir}/trading_signals.csv'):
        results['signals'] = pd.read_csv(f'{results_dir}/trading_signals.csv', index_col=0)
        results['signals'].index = pd.to_datetime(results['signals'].index)
    
    # Load strategy returns
    if os.path.exists(f'{results_dir}/strategy_returns.csv'):
        results['returns'] = pd.read_csv(f'{results_dir}/strategy_returns.csv', index_col=0)
        results['returns'].index = pd.to_datetime(results['returns'].index)
    
    return results

def calculate_advanced_metrics(returns_df):
    """
    Calculate advanced performance metrics for trading strategies.
    
    Parameters:
    -----------
    returns_df : pandas.DataFrame
        DataFrame containing strategy returns.
        
    Returns:
    --------
    metrics_df : pandas.DataFrame
        DataFrame containing advanced performance metrics.
    """
    # Define metrics to calculate
    metrics = {
        'Annual Return': ep.annual_return,
        'Cumulative Returns': ep.cum_returns_final,
        'Annual Volatility': ep.annual_volatility,
        'Sharpe Ratio': ep.sharpe_ratio,
        'Calmar Ratio': ep.calmar_ratio,
        'Stability': ep.stability_of_timeseries,
        'Max Drawdown': ep.max_drawdown,
        'Omega Ratio': ep.omega_ratio,
        'Sortino Ratio': ep.sortino_ratio,
        'Skew': ep.skew,
        'Kurtosis': ep.kurtosis,
        'Tail Ratio': ep.tail_ratio,
        'Daily Value at Risk': lambda x: ep.value_at_risk(x, period='daily'),
        'Alpha': lambda x: ep.alpha(x, returns_style='arithmetic'),
        'Beta': lambda x: ep.beta(x, returns_style='arithmetic')
    }
    
    # Calculate metrics for each strategy
    metrics_df = pd.DataFrame()
    
    for col in returns_df.columns:
        if col.endswith('_returns') and not col.endswith('_cum_returns'):
            strategy_returns = returns_df[col].dropna()
            
            if not strategy_returns.empty:
                strategy_metrics = {}
                
                for metric_name, metric_func in metrics.items():
                    try:
                        strategy_metrics[metric_name] = metric_func(strategy_returns)
                    except:
                        strategy_metrics[metric_name] = np.nan
                
                metrics_df[col.replace('_returns', '')] = pd.Series(strategy_metrics)
    
    return metrics_df

def analyze_drawdowns(returns_df, top_n=5):
    """
    Analyze top drawdowns for each strategy.
    
    Parameters:
    -----------
    returns_df : pandas.DataFrame
        DataFrame containing strategy returns.
    top_n : int
        Number of top drawdowns to analyze.
        
    Returns:
    --------
    drawdowns : dict
        Dictionary containing drawdown analysis for each strategy.
    """
    drawdowns = {}
    
    for col in returns_df.columns:
        if col.endswith('_returns') and not col.endswith('_cum_returns'):
            strategy_returns = returns_df[col].dropna()
            
            if not strategy_returns.empty:
                try:
                    strategy_drawdowns = pf.timeseries.gen_drawdown_table(strategy_returns, top=top_n)
                    drawdowns[col.replace('_returns', '')] = strategy_drawdowns
                except:
                    pass
    
    return drawdowns

def analyze_monthly_returns(returns_df):
    """
    Analyze monthly returns for each strategy.
    
    Parameters:
    -----------
    returns_df : pandas.DataFrame
        DataFrame containing strategy returns.
        
    Returns:
    --------
    monthly_returns : dict
        Dictionary containing monthly returns for each strategy.
    """
    monthly_returns = {}
    
    for col in returns_df.columns:
        if col.endswith('_returns') and not col.endswith('_cum_returns'):
            strategy_returns = returns_df[col].dropna()
            
            if not strategy_returns.empty:
                try:
                    monthly = pf.timeseries.aggregate_returns(strategy_returns, 'monthly')
                    monthly_returns[col.replace('_returns', '')] = monthly
                except:
                    pass
    
    return monthly_returns

def plot_cumulative_returns(returns_df, figsize=(14, 8), title='Cumulative Strategy Returns'):
    """
    Plot cumulative returns for each strategy.
    
    Parameters:
    -----------
    returns_df : pandas.DataFrame
        DataFrame containing strategy returns.
    figsize : tuple
        Figure size.
    title : str
        Plot title.
    """
    plt.figure(figsize=figsize)
    
    # Plot cumulative returns for each strategy
    for col in returns_df.columns:
        if col.endswith('_returns') and not col.endswith('_cum_returns'):
            strategy_returns = returns_df[col].dropna()
            
            if not strategy_returns.empty:
                # Calculate cumulative returns
                cum_returns = (1 + strategy_returns).cumprod()
                plt.plot(cum_returns.index, cum_returns, label=col.replace('_returns', ''))
    
    plt.title(title, fontsize=16)
    plt.xlabel('Date', fontsize=12)
    plt.ylabel('Cumulative Returns', fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.legend(loc='best')
    
    # Format x-axis to show months
    plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
    plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=1))
    plt.xticks(rotation=45)
    
    plt.tight_layout()
    plt.savefig('results/cumulative_returns_plot.png', dpi=300)
    plt.close()

def plot_drawdowns(returns_df, top_n=3, figsize=None):
    """
    Plot drawdowns for each strategy.
    
    Parameters:
    -----------
    returns_df : pandas.DataFrame
        DataFrame containing strategy returns.
    top_n : int
        Number of strategies to plot.
    figsize : tuple
        Figure size.
    """

    if figsize is None:
        figsize = (14, 8 * top_n)
    # Select top performing strategies based on Sharpe ratio
    top_strategies = []
    
    for col in returns_df.columns:
        if col.endswith('_returns') and not col.endswith('_cum_returns'):
            strategy_returns = returns_df[col].dropna()
            
            if not strategy_returns.empty:
                sharpe = ep.sharpe_ratio(strategy_returns)
                top_strategies.append((col.replace('_returns', ''), sharpe))
    
    # Sort strategies by Sharpe ratio
    top_strategies.sort(key=lambda x: x[1], reverse=True)
    top_strategies = [s[0] for s in top_strategies[:top_n]]
    
    # Plot drawdowns for top strategies
    plt.figure(figsize=figsize)
    
    for i, strategy in enumerate(top_strategies):
        strategy_returns = returns_df[f'{strategy}_returns'].dropna()
        
        if not strategy_returns.empty:
            plt.subplot(top_n, 1, i+1)
            
            # Calculate underwater plot
            underwater = pf.timeseries.cum_returns(strategy_returns, starting_value=1) / \
                         pf.timeseries.cum_returns(strategy_returns, starting_value=1).cummax() - 1
            
            underwater.plot(kind='area', color='coral', alpha=0.7)
            
            plt.title(f'{strategy} Drawdowns', fontsize=14)
            plt.xlabel('Date', fontsize=12)
            plt.ylabel('Drawdown', fontsize=12)
            plt.grid(True, alpha=0.3)
            
            # Format x-axis to show months
            plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
            plt.gca().xaxis.set_major_locator(mdates.MonthLocator(interval=1))
            plt.xticks(rotation=45)
    
    plt.tight_layout()
    plt.savefig('results/drawdowns_plot.png', dpi=300)
    plt.close()

def plot_monthly_heatmap(returns_df, top_n=5, figsize=(14, 10)):
    """
    Plot monthly returns heatmap for top strategies.
    
    Parameters:
    -----------
    returns_df : pandas.DataFrame
        DataFrame containing strategy returns.
    top_n : int
        Number of top strategies to include.
    figsize : tuple
        Figure size.
    """
    # Select top performing strategies based on Sharpe ratio
    top_strategies = []
    
    for col in returns_df.columns:
        if col.endswith('_returns') and not col.endswith('_cum_returns'):
            strategy_returns = returns_df[col].dropna()
            
            if not strategy_returns.empty:
                sharpe = ep.sharpe_ratio(strategy_returns)
                top_strategies.append((col.replace('_returns', ''), sharpe))
    
    # Sort strategies by Sharpe ratio
    top_strategies.sort(key=lambda x: x[1], reverse=True)
    top_strategies = [s[0] for s in top_strategies[:top_n]]
    
    # Calculate monthly returns for top strategies
    monthly_returns = {}
    
    for strategy in top_strategies:
        strategy_returns = returns_df[f'{strategy}_returns'].dropna()
        
        if not strategy_returns.empty:
            monthly = strategy_returns.resample('M').apply(lambda x: (1 + x).prod() - 1)
            monthly_returns[strategy] = monthly
    
    # Convert to DataFrame
    monthly_df = pd.DataFrame(monthly_returns)
    
    # Add month and year columns
    monthly_df['Year'] = monthly_df.index.year
    monthly_df['Month'] = monthly_df.index.month
    
    # Create pivot table for heatmap
    for strategy in top_strategies:
        plt.figure(figsize=figsize)
        
        pivot = monthly_df.pivot_table(index='Year', columns='Month', values=strategy)
        
        # Plot heatmap
        sns.heatmap(pivot, annot=True, fmt='.2%', cmap='RdYlGn', center=0,
                   linewidths=1, cbar_kws={'label': 'Monthly Return'})
        
        plt.title(f'{strategy} Monthly Returns', fontsize=16)
        plt.xlabel('Month', fontsize=12)
        plt.ylabel('Year', fontsize=12)
        
        # Set month names
        month_names = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
        plt.gca().set_xticklabels(month_names, rotation=0)
        
        plt.tight_layout()
        plt.savefig(f'results/{strategy}_monthly_heatmap.png', dpi=300)
        plt.close()

def plot_rolling_metrics(returns_df, window=21, figsize=(14, 16)):
    """
    Plot rolling metrics for each strategy.
    
    Parameters:
    -----------
    returns_df : pandas.DataFrame
        DataFrame containing strategy returns.
    window : int
        Rolling window size in days.
    figsize : tuple
        Figure size.
    """
    # Select strategies
    strategies = []
    
    for col in returns_df.columns:
        if col.endswith('_returns') and not col.endswith('_cum_returns'):
            strategy_name = col.replace('_returns', '')
            strategies.append(strategy_name)
    
    if not strategies:
        return
    
    # Calculate rolling metrics
    rolling_metrics = pd.DataFrame(index=returns_df.index)
    
    for strategy in strategies:
        returns = returns_df[f'{strategy}_returns'].dropna()
        
        if not returns.empty:
            # Rolling Sharpe ratio
            rolling_metrics[f'{strategy}_sharpe'] = returns.rolling(window).apply(
                lambda x: ep.sharpe_ratio(x, annualization=np.sqrt(252 / window))
            )
            
            # Rolling volatility
            rolling_metrics[f'{strategy}_vol'] = returns.rolling(window).std() * np.sqrt(252)
            
            # Rolling returns
            rolling_metrics[f'{strategy}_ret'] = (1 + returns).rolling(window).apply(
                lambda x: (1 + x).prod() - 1
            ) * (252 / window)
    
    # Plot rolling metrics
    plt.figure(figsize=figsize)
    
    # Plot rolling Sharpe ratio
    plt.subplot(3, 1, 1)
    for strategy in strategies:
        plt.plot(rolling_metrics.index, rolling_metrics[f'{strategy}_sharpe'], label=strategy)
    
    plt.title(f'Rolling {window}-day Sharpe Ratio', fontsize=14)
    plt.xlabel('Date', fontsize=12)
    plt.ylabel('Sharpe Ratio', fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.legend(loc='best')
    
    # Plot rolling volatility
    plt.subplot(3, 1, 2)
    for strategy in strategies:
        plt.plot(rolling_metrics.index, rolling_metrics[f'{strategy}_vol'], label=strategy)
    
    plt.title(f'Rolling {window}-day Annualized Volatility', fontsize=14)
    plt.xlabel('Date', fontsize=12)
    plt.ylabel('Volatility', fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.legend(loc='best')
    
    # Plot rolling returns
    plt.subplot(3, 1, 3)
    for strategy in strategies:
        plt.plot(rolling_metrics.index, rolling_metrics[f'{strategy}_ret'], label=strategy)
    
    plt.title(f'Rolling {window}-day Annualized Returns', fontsize=14)
    plt.xlabel('Date', fontsize=12)
    plt.ylabel('Returns', fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.legend(loc='best')
    
    plt.tight_layout()
    plt.savefig('results/rolling_metrics.png', dpi=300)
    plt.close()

def analyze_trade_statistics(signals_df, returns_df):
    """
    Analyze trade statistics for each strategy.
    
    Parameters:
    -----------
    signals_df : pandas.DataFrame
        DataFrame containing trading signals.
    returns_df : pandas.DataFrame
        DataFrame containing strategy returns.
        
    Returns:
    --------
    trade_stats : pandas.DataFrame
        DataFrame containing trade statistics.
    """
    trade_stats = pd.DataFrame()
    
    for col in signals_df.columns:
        if col.endswith('_position'):
            strategy = col.replace('_position', '')
            
            # Skip if returns not available
            if f'{strategy}_returns' not in returns_df.columns:
                continue
            
            positions = signals_df[col].fillna(0)
            returns = returns_df[f'{strategy}_returns'].fillna(0)
            
            # Calculate position changes (trades)
            position_changes = positions.diff().fillna(0)
            
            # Number of trades
            n_trades = (position_changes != 0).sum()
            
            # Number of long/short positions
            n_long = (positions == 1).sum()
            n_short = (positions == -1).sum()
            
            # Winning trades
            winning_trades = ((position_changes != 0) & (returns > 0)).sum()
            
            # Win rate
            win_rate = winning_trades / n_trades if n_trades > 0 else 0
            
            # Average profit per trade
            avg_profit = returns.sum() / n_trades if n_trades > 0 else 0
            
            # Maximum consecutive wins/losses
            trade_results = []
            
            for i, (pos_change, ret) in enumerate(zip(position_changes, returns)):
                if pos_change != 0:
                    trade_results.append(1 if ret > 0 else 0)
            
            # Find max consecutive wins/losses
            max_cons_wins = 0
            max_cons_losses = 0
            
            if trade_results:
                current_streak = 1
                current_result = trade_results[0]
                
                for i in range(1, len(trade_results)):
                    if trade_results[i] == trade_results[i-1]:
                        current_streak += 1
                    else:
                        if trade_results[i-1] == 1:  # Win
                            max_cons_wins = max(max_cons_wins, current_streak)
                        else:  # Loss
                            max_cons_losses = max(max_cons_losses, current_streak)
                        
                        current_streak = 1
                        current_result = trade_results[i]
                
                # Check last streak
                if current_result == 1:  # Win
                    max_cons_wins = max(max_cons_wins, current_streak)
                else:  # Loss
                    max_cons_losses = max(max_cons_losses, current_streak)
            
            # Store statistics
            trade_stats[strategy] = pd.Series({
                'Total Trades': n_trades,
                'Long Positions': n_long,
                'Short Positions': n_short,
                'Winning Trades': winning_trades,
                'Losing Trades': n_trades - winning_trades,
                'Win Rate': win_rate,
                'Average Profit per Trade': avg_profit,
                'Max Consecutive Wins': max_cons_wins,
                'Max Consecutive Losses': max_cons_losses
            })
    
    return trade_stats

def main():
    """
    Main function to run the analysis.
    """
    print("="*80)
    print(" ES FUTURES TRADING RESULTS ANALYSIS ")
    print("="*80)
    
    # Create results directory if it doesn't exist
    os.makedirs('results', exist_ok=True)
    
    # Step 1: Load results
    print("\nSTEP 1: Loading results...")
    results = load_results()
    
    # Check if results were loaded successfully
    if not results:
        print("No results found. Please run the pipeline first.")
        return
    
    # Step 2: Calculate advanced metrics
    print("\nSTEP 2: Calculating advanced metrics...")
    if 'returns' in results:
        metrics_df = calculate_advanced_metrics(results['returns'])
        metrics_df.to_csv('results/advanced_metrics.csv')
        
        # Print metrics table
        print("\nAdvanced Performance Metrics:")
        metrics_to_display = ['Annual Return', 'Cumulative Returns', 'Annual Volatility', 
                              'Sharpe Ratio', 'Sortino Ratio', 'Max Drawdown']
        
        print(tabulate(metrics_df.loc[metrics_to_display].T.round(4), 
                      headers='keys', tablefmt='grid'))
    
    # Step 3: Analyze drawdowns
    print("\nSTEP 3: Analyzing drawdowns...")
    if 'returns' in results:
        drawdowns = analyze_drawdowns(results['returns'])
        
        # Save drawdowns to CSV
        for strategy, dd_table in drawdowns.items():
            dd_table.to_csv(f'results/{strategy}_drawdowns.csv')
        
        # Print top drawdown for each strategy
        print("\nTop Drawdowns:")
        for strategy, dd_table in drawdowns.items():
            if not dd_table.empty:
                print(f"\n{strategy}:")
                print(tabulate(dd_table.head(1).round(4), headers='keys', tablefmt='grid'))
    
    # Step 4: Plot results
    print("\nSTEP 4: Plotting results...")
    
    # Plot cumulative returns
    if 'returns' in results:
        plot_cumulative_returns(results['returns'])
        print("Cumulative returns plot saved to results/cumulative_returns_plot.png")
        
        # Plot drawdowns
        plot_drawdowns(results['returns'])
        print("Drawdowns plot saved to results/drawdowns_plot.png")
        
        # Plot monthly heatmap
        plot_monthly_heatmap(results['returns'])
        print("Monthly return heatmaps saved to results/ directory")
        
        # Plot rolling metrics
        plot_rolling_metrics(results['returns'])
        print("Rolling metrics plot saved to results/rolling_metrics.png")
    
    # Step 5: Analyze trade statistics
    print("\nSTEP 5: Analyzing trade statistics...")
    if 'signals' in results and 'returns' in results:
        trade_stats = analyze_trade_statistics(results['signals'], results['returns'])
        trade_stats.to_csv('results/trade_statistics.csv')
        
        # Print trade statistics
        print("\nTrade Statistics:")
        print(tabulate(trade_stats.T.round(4), headers='keys', tablefmt='grid'))
    
    print("\nAnalysis completed successfully!")

if __name__ == "__main__":
    main()